2-)
Na solução, dois semáforos (vazioCont e cheioCont) são utilizados. No procedimento Produtor(), sempre que um item é produzido, 
aguarda-se até que o semáforo emptyCount esteja liberado, para que então ele possa ser inserido no
Buffer. Ao inserir-se um item no buffer, incrementa-se cheioCont, tornando possível que algum
item seja consumido.

Analogamente, no caso dos procedimentos do tipo Consumidor(), espera-se até que cheioCont esteja
liberado (assumiu um valor maior do que zero) para que então seja possível recuperar algum item do 
buffer. Quando esse item é recuperado, incrementa-se vazioCont, tornando-o maior do que zero.

sem_t vazioCont, cheioCont;

void* threadProdutor(void *id_produtor)
{
	while(true)
	{
		item = produzirItem();
		sem_wait(&vazioCont);
		inserirNoBuffer(item);
		sem_post(&cheioCont);
	}
}

procedure threadConsumidor(void *id_consumidor)
{
	while(true)
	{
		sem_wait(&cheioCont);
		item = removerItemDoBuffer();
		sem_post(&vazioCont);
		consumirItem(item);
	}
}

3-)

Assume-se que a classe Monitor já possui atributos ângulo, frame, duração, etc.

class Monitor
{	
	mutex video_mutex;

	public:
		Monitor();
		FrameDeVideo* getCurrentFrame();
		void moveCamera(int angulo);
		int getDuracaoVideo();
};

FrameDeVideo* Monitor::getCurrentFrame()
{
	return frameAtual;
}

void Monitor::moveCamera(int angulo)
{
	video_mutex.lock()
	this->angulo += angulo;
	video_mutex.unlock();
}

int getDuracaoVideo()
{
	return duracao;
}

4-)


